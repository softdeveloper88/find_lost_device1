import 'dart:convert';import 'package:find_lost_device1/model/device_model.dart';import 'package:find_lost_device1/screens/device_detail_screen.dart';import 'package:firebase_database/firebase_database.dart';import 'package:flutter/material.dart';import 'package:geocoder/geocoder.dart';import 'package:geocoder/model.dart';import 'package:geolocator/geolocator.dart';import 'package:http/http.dart' as http;import 'package:progress_dialog/progress_dialog.dart';// const fetchBackground = "fetchBackground";// void callbackDispatcher() {//   Workmanager.executeTask((task, inputData) async {//     switch (task) {//       case fetchBackground://         Position userLocation = await Geolocator().getCurrentPosition(desiredAccuracy: LocationAccuracy.high);//         break;//     }//     return Future.value(true);//   });// }// const fetchBackground = "fetchBackground";// void callbackDispatcher() {//   Workmanager.executeTask((task, inputData) async {//     switch (task) {//       case fetchBackground://         Position userLocation = await Geolocator().getCurrentPosition(desiredAccuracy: LocationAccuracy.high);//         notif.Notification notification = new notif.Notification();//         notification.showNotificationWithoutSound(userLocation);//         break;//     }//     return Future.value(true);//   });// }class FindLocationScreen extends StatefulWidget {  String email, displayName, photoURL, uid;  FindLocationScreen({this.email, this.displayName, this.photoURL, this.uid});  @override  _FindLocationScreenState createState() => _FindLocationScreenState();}class _FindLocationScreenState extends State<FindLocationScreen> {  ProgressDialog pr;  Position _currentPosition;  String _currentAddress;  final Geolocator geolocator = Geolocator()..forceAndroidLocationManager;  List<DeviceModel> deviceModel = [];  Position position;  Geolocator geoLocator = Geolocator();  void _getUserPosition() async {    GeolocationStatus geolocationStatus =        await Geolocator().checkGeolocationPermissionStatus();    Position userLocation = await geoLocator.getCurrentPosition(        desiredAccuracy: LocationAccuracy.high);    setState(() {      position = userLocation;      print("location: $position");    });  }  _getCurrentLocation() {    geolocator        .getCurrentPosition(desiredAccuracy: LocationAccuracy.best)        .then((Position position) {      setState(() {        _currentPosition = position;      });      _getAddressFromLatLng();    }).catchError((e) {      print(e);    });  }  _getAddressFromLatLng() async {    try {      final coordinates = new Coordinates(          _currentPosition.latitude, _currentPosition.longitude);      var addresses =          await Geocoder.local.findAddressesFromCoordinates(coordinates);      var first = addresses.first;      print("${first.addressLine}");      setState(() {        // print("${place.subLocality}, ${place.locality}, ${place.country}");        _currentAddress = "${first.addressLine}";      });    } catch (e) {      print(e);    }  }  @override  void initState() {    this._getUserPosition();    _getCurrentLocation();    // Workmanager.initialize(    //   callbackDispatcher,    //   isInDebugMode: true,    // );    //    // Workmanager.registerPeriodicTask(    //   "1",    //   fetchBackground,    //   frequency: Duration(minutes: 1),    // );    super.initState();  }  @override  Widget build(BuildContext context) {    pr=ProgressDialog(context,isDismissible: false);    return Scaffold(        appBar: AppBar(title: Text("Find Location Screen")),        body: Container(            width: double.infinity,            height: MediaQuery.of(context).size.height,            alignment: Alignment.center,            padding: EdgeInsets.all(40),            //set width and height of outermost wrapper to 100%;            child: Column(              children: [                if (_currentPosition != null && _currentAddress != null)                  Text(_currentAddress),                Expanded(                    child: Center(                  child: FutureBuilder(                      future: FirebaseDatabase.instance.reference().once(),                      builder: (BuildContext context,                          AsyncSnapshot<DataSnapshot> snapshot) {                        if (snapshot.hasData) {                          deviceModel.clear();                          Map<dynamic, dynamic> values = snapshot.data.value;                          values.forEach((key, values) {                            if (values['email'] == widget.email) {                              deviceModel.add(DeviceModel(                                  key,                                  values['deviceModel'],                                  values['email'],                                  values['name'],                                  values['manufactureName'],                                  values['deviceToken'],                                  values['lat'],                                  values['lng']));                            }                          });                          return ListView.builder(                              itemCount: deviceModel.length,                              itemBuilder: (context, index) {                                return Card(                                  color: Colors.red,                                  //elevation: 2.0,                                  child: GestureDetector(                                    onTap: () {                                      print("click");                                      pr.show();                                      sendFcmMessage(                                          "Location",                                          "Where is my mobile",                                          deviceModel[index]);                                    },                                    child: new ListTile(                                      title: new Text(                                          "Device Mode:${deviceModel[index].deviceModel}"),                                    ),                                  ),                                );                              });                        } else if (snapshot.hasError) {                          return Icon(Icons.error_outline);                        } else {                          return CircularProgressIndicator();                        }                      }),                ))              ],            )));  }  Future<bool> sendFcmMessage(      String title, String message, DeviceModel info) async {    try {      var url = 'https://fcm.googleapis.com/fcm/send';      var header = {        "Content-Type": "application/json",        "Authorization":        "Bearer AAAAzpd-_iA:APA91bGqz8ppYKEP2Ff6GRn6Ksh3X-QwAGPx-c7vQTr_tpEa-y6C2VjJKAOc3duHuOrfDyJV2EE5kxVFlQLjnXYA0aFV700SjSBPb0bgC4rCxJzUI9ieeoXu4x2CvReJGfo5-wNOtTsl",      };      // var request = {      //   "notification": {      //     "title": title,      //     "text": message,      //     "sound": "default",      //     "color": "#990000",      //   },      //   "priority": "high",      //   "to": "/topics/all",      // };      // var request = {      //   'notification': {'title': title, 'body': message},      //   'data': {      //     'click_action': 'FLUTTER_NOTIFICATION_CLICK',      //     'type': 'COMMENT'      //   },      //   'to':token      // };      var request = {        "registration_ids": [info.deviceToken],        "data": {"body": message, "title": title}      };      var response = await http          .post(Uri.parse(url), headers: header, body: json.encode(request))          .then((value) {        pr.hide();        Navigator.pushReplacement(          context,          new MaterialPageRoute(              builder: (ctxt) =>              new DeviceDetailScreen(                email: info.email,                displayName: info.name,                deviceId: info.id,              )),        );      });      return true;    } catch (e) {      print(e);      return false;    }  }  Future<String> _getDeviceAddressFromLatLng(double lat, double lng) async {    var _currentAddress2;    try {      // List<Placemark> p = await Geocoder(      //     lat,lng);      // Placemark place = p[0];      final coordinates =          new Coordinates(position.latitude, position.longitude);      var addresses =          await Geocoder.local.findAddressesFromCoordinates(coordinates);      var first = addresses.first;      print("${first.addressLine}");      setState(() {        _currentAddress2 = "${first.addressLine}";      });    } catch (e) {      print(e);    }    return _currentAddress2;  }}